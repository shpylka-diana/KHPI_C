# Лабораторна робота №8. Вступ до блок-схем алгоритмів. №9. Вступ до документації коду (частина 1). №10. Вступ до документації проекту.
## 1 Вимоги
* **1.1 Розробник**
*	Шпилька Діана Олександрівна
*   студентка групи КІТ – 320
*   17-jan-2021

* **1.2 Загальне завдання** 
* - Переробити програми, що були розроблені під час виконання лабораторних робіт з тем "Масиви" та "Цикли" таким чином, щоб використовувалися функції для обчислення результату. 

* **1.3 Індивідуальне завдання** 
* **Розробити**: - програму яка визначае найбільший спільнийй дільник для двох заданих чисел.
* - заповнити масив із заданої кількості елементів простими числами, що не повторюються.

## 2 Опис програми
**2.1 Функціональне призначення** 
* Визначення найбільшого спільного дільника для двох чисел.
* Заповнення масиву простими числами, що не повторюються.
* Результат обчислення зберігається у змінних *result_while*, *result_for*, *result_do*.
* Демонстрація отриманих результатів передбачає покрокове виконання програми в режимі налагодження.

**2.2 Опис логічної структури**
* За допомогою генератору псевдовипадкових чисел rand генеруємо значення для *x, y*, для отримання результату використовується функція * get_nod_while, get_nod_for, get_nod_do, get_prime_num_array *, що знаходиться в *main.c*

*   **Основна функція** 
*   `int main`
*   *Призначення*: головна функція
*   *Схема алгоритму функції* подана на рис.1,2
*   *Опис роботи*: виклик функції для генерації псевдовипадкових чисел, генерація числа для змінної, обчислення результату через цикл For/While/DoWhile за допомогою функції.

![Рисунок 1 - Схема алгоритму функції main в lab05](doc/assets/main_1.png)
![Рисунок 2 - Схема алгоритму функції main в lab06](doc/assets/main_2.png)

*   **Функція знаходження нсд циклом for**
*   `int perfectnum_for` (int num)
*   *Призначення*: визначення нсд за допомогою циклу for.
*   *Схема алгоритму функції* подана на рис.3
*   *Опис роботи*: - програма виконує ділення з остачею заданих чисел на менше з цих чисел та на всі інші числа менші за нього, допоки не знайде число, при діленні на яке, остача буде рівна нулю.
* - програма встановлює розмір масиву та його діапазон. Потім, між двома числами, які входять в діапазон, виконується ділення з остачею. Якщо результат ділення нуль, то число записується в масив, якщо один — пропускається.

![Рисунок 3 - Схема алгоритму функції  get_nod_for](doc/assets/for_1.png)
     
*   **Функція знаходження нсд циклом while**
*   `int perfectnum_while` (int num)
*   *Призначення*: визначення чи є число досконалим за допомогою циклу while.
*   *Схема алгоритму функції* подана на рис.4
*   *Опис роботи*: - програма виконує ділення з остачею заданих чисел на менше з цих чисел та на всі інші числа менші за нього, допоки не знайде число, при діленні на яке, остача буде рівна нулю.
* - програма встановлює розмір масиву та його діапазон. Потім, між двома числами, які входять в діапазон, виконується ділення з остачею. Якщо результат ділення нуль, то число записується в масив, якщо один — пропускається.
    	
![Рисунок 4 - Схема алгоритму функції get_nod_while](doc/assets/while_1.png)

*   **Функція знаходження нсд циклом do while**
*   `int perfectnum_dowhile` (int num)
*   *Призначення*: визначення чи є число досконалим за допомогою циклу do while.
*   *Схема алгоритму функції* подана на рис.5
*   *Опис роботи*: - програма виконує ділення з остачею заданих чисел на менше з цих чисел та на всі інші числа менші за нього, допоки не знайде число, при діленні на яке, остача буде рівна нулю.
* - програма встановлює розмір масиву та його діапазон. Потім, між двома числами, які входять в діапазон, виконується ділення з остачею. Якщо результат ділення нуль, то число записується в масив, якщо один — пропускається.
    	
![Рисунок 5 - Схема алгоритму функції get_nod_do](doc/assets/do_1.png)

**Структура проекту**
```
.
├── doc
│   ├── assets
│   │   ├── do_1.png
│   │   ├── for_1.png
│   │   ├── main_1.png
│   │   ├── main_2.png
│   │   ├── void_2.png
│   │   └── while_1.png
│   ├── lab08_09_10.docx
│   ├── lab08_09_10.pdf
│   └── lab08_09_10.md
├── Doxyfile
├── lab05_01
│   ├── README.md
│   └── src
│       └── main.c
├── lab06_02
│   ├── README.md
│   └── src
│       └── main.c
├── Makefile
└── README.md

```
**2.3 Важливі елементи програми**

**Генерація псевдовипадкового числа**

   ```
    srand(time(NULL));
	int x = rand() % 23 + 2;
	int y = rand() % 23 + 2;
	
	srand(time(NULL));
	int len = rand() % 101 + 10;
	
   ```
**Обчислення через функцію get_nod_for**

   ```
    int nod_for = 0;
	for (; num1 > 0 && num2 > 0;) {
		(num1 > num2) ? (num1 %= num2) : (num2 %= num1);
		nod_for = num1 + num2;
	}
	int result_for = nod_for;
	return result_for
	}
	
   ```
**Обчислення через функцію get_nod_while**

   ```
   
    int nod_while = 0;
	while (num1 > 0 && num2 > 0) {
		if (num1 > num2) {
			num1 %= num2;
		} else if (num1 < num2) {
			num2 %= num1;
		}
	nod_while = num1 + num2;
	}
	int result_while = nod_for;
		return result_while;
	}	
  
   ```   
**Обчислення через функцію get_nod_do**

   ```
  int nod_do = 0;
	do {
		if (num1 > num2) {
			num1 %= num2;
		} else if (num1 < num2) {
			num2 %= num1;
		}
	nod_do = num1 + num2;
	} while (num1 > 0 && num2 > 0);
	int result_do = nod_do;
	return result_do;
	}
	
   ```   

## 3 Варіанти використання
*   Для демонстрації результатів використовується покрокове виконання програми в інтегрованому середовищі *Nemiver*. Нижче наводиться послідовність дій запуску програми у режимі відлагодження.

![Рисунок 6 – результати роботи програми lab05](doc/assets/result_1.png)
![Рисунок 7 – результати роботи програми lab06](doc/assets/result_2.png)

## Висновки
*   При виконанні даної лабораторної роботи було набуто практичного досвіду роботи з функціями та генератором псевдовипадкового числа rand.
